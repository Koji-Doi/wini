#!/usr/bin/perl
=head1 NAME

WINI - Something like wiki

=head1 SYNOPSIS

=head2 Examples:

 my $htmltext = wini(<<'EOT');
 ! Large heading
 !! Middle heading
 !!! Small heading

 * list item 1
 ** nested list item
 * list item 2
 * list item 3

 Paragraphs should be separated by null line, like wiki or markdown. Line breaks in plain text are ignored. 
 Thus this is not a first sentence of the second paragraph, but the second sentence of the first paragraph.

 This is the second paragraph.

 WINI supports 'macro', or inline templates. Text decoration (emphasis, italize, etc.) can be realized using simple macros. Text decoration macro include '{{b|bold text}}' to make text bold, '{{i|italic text}} to make text italic. 

 WINI also supports [!'fig.jpg' inline image], ['http://example.com' inline hyper link to other site]

 EOT

=head1 DESCRIPTION

WINI is a simple markup language to build html5 text. 

WINI stands for "WIki ni NIta nanika", which  means "something like wiki" in Japanese. As suggested from this naming, WINI is designed with reference to wiki and markdown, and thus its grammar is very similar with those language. Tus, it is very easy to find out usage.

Otherwise, WINI is designed with a strong emphasis on affinity with html5 and easiliness of complex html table construction.  Today many people try to build and maintain blogs, wikipedia-like sites, etc. WINI must be useful for those who should produce or update huge number of pages daily within a time limit.

=head2 Basic feature

Except for some special characters basically put at the top of each line, users can write down plain text as usual in text editor.
Like wiki and markdown, single line breaks with in text are ignored.  Also as wiki and markdown, empty lines, generated by sequence two or more line breaks, are treated as paragraph separator.

Users can include any valid html5 tags within the text. These tags are passed to WINI interpreter as is.

=head2 Special markup

=head3 Headers

Users can express section heading (h1, h2, h3, h4, and h5 tags in html5) by '!' placed at the top of line.

 ! Large item

Large item lead by single '!' is the largest headings in article section. It is largest but translated to '<h3 class="wini">...</h3>', because WINI suppose that h1 and h2 tags are used as 'page title' or 'page subtitle', rather than headings in sections.

=head3 List item

Texts with '*' at the top of line are unnumbered list items.  They are expressed with <li> tags within <ul>...</ul> area in result html file.

 * unnumbered list item 1
 * unnumbered list item 2

Text with '#' at the top of line are numbered list items.  They are expressed with <li>tags within <ol>...</ol> area in result html file.

 # numbered list item 1
 # numbered list item 2

=head3 Table

The table is represented as a line starting with "|".

A table row contains several data blocks and boundary blocks. Data blocks correspond to Excel “cells”.Border blocks are separators of data blocks, and give some options showing how to treat following data. Border blocks must begin with "|" followed by more than zero option characters. Blocks must be separated by spaces.

==head4 Simple example

| head1 | head 2 |head 3 |
| 1     | 2      | 3     |
| 4     | 5      | 6     |



=head3 Macro

WINI support 'macros', or inline templates, to achieve various html expressions easily. A typical macro looks like:

{{macro|opt=x}}

As shown above, each macro begin with `{{`, followed by macro name, and end with '}}'. Macro names just consists of alphabets, numerics and underscore, and basically case-insensitive. Some macros include options after macro name. Options are separated by '|'.

=head3 Text decoration

Text decoration are realized by macros.


=over 4

=item * italic: {{i|italic text}} or {{/|italic text}}

=item * bold: {{b|bold text}} or {{*|bold text}}

=item * underline: {{u| with underline}} or {{_| with underline}}

=item * striked: {{s| striked}} or {{-| striked}}

=item * strong: {{**| strong}}

=back

User can specify 2 or 3 types of text decoration with one macro, e.g. '{{*/|bold and italic text}}'.

WINI also support 'B','I','U', and 'S' macros supporting correspoding html5 logical tags. Note that these tags in html5 are, unlike those in html4 or older html, 'logical' tags. They mean that the specified text should be logically enphasized, and does not mean those text should be type set as physically decorated by italization or something like that.

WINI normally ignore cases of macro names, but 'i','I','b','B','s','S','u', and 'U' are exceptions of this rule, and {{i|...}} and {{I|...}} are clearly different. For example, {{I|target text}} is translated as '<i>target text</i>', while {{i|target text}} is translated as '<span style="font-style:italic;">target text</span>'.

Some text decoration macros use non-alphabetical characters as their name.  The macro {{**|target}} is translated as '<strong>target</strong>'. More than 3 astarisks are allowed, where multiple '<strong>' tags are placed. This mean that users can type '{{****|very important text}}' to generate '<strong><strong><strong>very importat text</strong></strong></strong>', which is a certified HTML5 typesetting. It is also possible to type '{{** *|logically strong and physically bold text}}' to set both '**' and '*' at the same time.

=cut

use strict;
use Data::Dumper;
use Pry;

my $baseurl = "http://localhost";

my $txt = <<'EOD';
ABC
DEG

* u1
* u2
** u1-1
** u1-2
*** u1-2-1
*** u1-2-2
* u3

; named item 1
: named item 1 desc
; named item 2
: named item 2 desc

* i2
*: nomark list item1
*: nomark list item2
* i3

|             a | b  | c  |
|..classX     1 | 2  | 3  |
|          *  8 |.class2 9  | 10 | 
|^         * 11 | 12 | 13 |
|.classY..classX.classZ...classZZ     14 | 15 | 16 |

abc
{{B|def
ghij}}
{{B|klm}}

{{* ** **|strong strong}}
EOD

print "---\n$txt---\n";

print <<'EOD';
<!DOCTYPE html>
<html>
<head>
<style>
  table, td, th {border: 1px solid}
  table         {border-collapse: collapse}
  ol, ul,dl     {padding-left: 1em}
</style>
</head>
<body>
EOD

print wini($txt); #, {para=>'br'});

print <<'EOD';

</body>
</html>
EOD


sub close_listtag{
  my($ref, $l) = @_;
  my $n = $#$l;
  map{
    $$ref .= (' ' x ($n-$_)) . (($l->[$_] eq 'ul')?'</ul>':($l->[$_] eq 'ol')?'</ol>':'</dl>') . "\n";
  } 0..$n;
}

sub wini{
# wini($tagettext, {para=>'br', 'is_bs4'=>1, baseurl=>'http://example.com', nocr=>1});
  # para: paragraph mode (br:set <br>, p: set <p>, nb: no separation
  # nocr: whether CRs are conserved in result text. 0(default): conserved, 1: not conserved
  my($t0, $opt)         = @_;
  my $cr                = (defined $opt->{nocr} and $opt->{nocr}==1)
                          ?"\t":"\n"; # option to inhibit CR insertion (in table)
  my($baseurl, $is_bs4) = ($opt->{baseurl}, $opt->{is_bs4});
  my $para              = 'p'; # p or br or none
  (defined $opt->{para}) and $para = $opt->{para};

  # conv table to html
  $t0 =~ s/(^\s*\|.*?)[\n\r]+(?!\|)/make_table($1)/esmg;

  my $r;
  my @localclass = ('wini');
  ($is_bs4) and push(@localclass, "col-sm-12");
  my $myclass = ' class="'.join(' ',@localclass).'"';
  foreach my $t (split(/\n{2,}/, $t0)){
    my $lastlistdepth=0;
    my $ptype; # type of each paragraph (list, header, normal paragraph, etc.)
    while(1){ # loop while subst needed
      if(my($x,$cont) = $t=~/^(!+)\s*(.*)$/m){ # !!!...
        my $tag0 = length($x)+2; ($tag0>5) and $tag0="5";
        $t=~s#^(!+)\s*(.*)$#<h${tag0}${myclass}>$2</h${tag0}>#m;
        $ptype = 'header';
      }
      (
        $t =~ s!{{([IBUS])\|([^{}]*?)}}!{my $x=lc $1; "<$x>$2</$x>"}!esg or
        $t =~ s!{{i\|([^{}]*?)}}!<span style="font-style:italic;">$1</span>!g or
        $t =~ s!{{b\|([^{}]*?)}}!<span style="font-weight:bold;">$1</span>!g or
        $t =~ s!{{u\|([^{}]*?)}}!<span style="border-bottom: solid 1px;">$1</span>!g or
        $t =~ s!{{s\|([^{}]*?)}}!<span style="text-decoration: line-through;">$1</span>!g or
        $t =~ s!{{([-_/*]+[-_/* ]*)\|([^{}]*?)}}!xtags($1,$2)!eg or
        $t =~ s!\[(.*?)\]!make_a($1, $baseurl)!eg
      ) or last; # no subst need, then escape inner loop
    } # loop while subst needed
    my $t2='';

    # for list items
    my $listtagc;
    my @is_dl; # $is_dl[1]: whether list type of depth 1 is 'dl'
    my @listtagc;
    foreach my $l (split("\n", $t)){
      my($x, $listtype, $txt) = $l=~/^\s*([#*:;]*)([#*:;])\s*(.*)$/; # whether list item
      if($listtype ne ''){
        $ptype = 'list';
        my $listdepth = length($x)+length($listtype);
        ($listtype eq ';') and $is_dl[$listdepth]='dl';
        my($itemtag, $listtag) = ($listtype eq '*') ? qw/li ul/
                               : ($listtype eq ':') ? (($is_dl[$listdepth] eq 'dl')?qw/dd dl/:(qq{li style="list-style:none"}, 'ul'))
                               : ($listtype eq ';') ? qw/dt dl/ : qw/li ol/;
        my $itemtagc = $itemtag; # closing tag for list item
           $listtagc = $listtag; # closing tag for list
        $itemtagc =~ s/ .*//;
        $listtagc =~ s/ .*//;
        $listtagc[$listdepth] = $listtagc;
        # new list start?
        if($listdepth>$lastlistdepth){
          $t2 .= sprintf("%*s<$listtag>$cr",$listdepth,' ');
        }
        # new list end?
        #($lastlistdepth>$listdepth) and $listtypes[$listdepth]=0;
        for(my $i = $lastlistdepth-$listdepth; $i>0; $i--){
          $t2 .= sprintf("%*s</%s>$cr", $i+$listdepth, ' ', $listtagc[$i+$listdepth]);
        }
        $t2 .= sprintf("%*s<$itemtag>$txt</$itemtagc>$cr",$listdepth+1,' ');
        $lastlistdepth = $listdepth;
      }else{ # if not list item
        $t2 .= "$l\n";
      }
    } # $l
    if($lastlistdepth>0){
      $t2 .= sprintf("%*s", $lastlistdepth-1, ' ') . ("</$listtagc>" x $lastlistdepth) . $cr;
      $lastlistdepth=0;
    }

    $r .= ($ptype eq 'header' or $ptype eq 'list') ? "$t2\n"
        : ($para eq 'br')                          ? "$t2<br>$cr"
        : ($para eq 'nb')                          ? $t2 
                                                   : "<p${myclass}>\n$t2</p>$cr$cr"


  } # foreach $t
  
  return($r);
}

sub xtags{
  # {{/*_-|text}}
  my($tag0, $text)=@_;
  my @styles;
  my $r;
  my $strong=0;
  while($tag0=~/(\*+)/g){
    (length($1)>1) ? $strong++ : push(@styles, 'font-weight:bold;');
  }
  ($tag0=~/_/)  and push(@styles, 'border-bottom: solid 1px;');
  ($tag0=~/-/)  and push(@styles, 'text-decoration: line-through;');
  ($tag0=~m{/}) and push(@styles, 'font-style:italic;');
  $r = (scalar @styles > 0)?'<span style="' . join(' ', @styles) . qq{">$text</span>} : $text;
  ($strong) and $r = '<strong>'x$strong . $r . '</strong>'x$strong;
  return($r);
}

sub readpars{
  my($p, @list)=@_;
  my %pars; my @pars;
  foreach my $x (split(/\|/, $p)){
    if(my($k,$v) = $x=~/(\w+)\s*=\s*(.*)\s*/){
      $pars{$k}=$v;
    }else{
      push(@pars, $x);
    }
  }
  foreach my $k (@list){
    if(exists $pars{$k}){
      
    }else{
      my $x = shift(@pars);
      $pars{$k}=$x;
    }
  }
  return(\%pars);
}

sub escape{
  ($_)=@_;
  ($_) or return('');
  s/&/&amp;/g;
  s/</&lt;/g;
  s/>/&gt;/g;
  return($_);
}

# [[label|type|ja_name|en_name|ja_desc|en_desc|maxlen|minlen|maxval|minval|regexp|ncol|nrow]]
sub readblank{
  my($indata)=@_; # '[[a|b|c]]'
  ($indata)=$indata=~/(?:\[\[)?([^]]*)(?:\]\])?/;
  my $x = readpars($indata, qw/label type ja_name en_name ja_desc en_desc maxlen minlen maxval minval regexp ncol nrow/);
  return($x);
}

# [xxxx] -> <a href="www">...</a>
sub make_a{
  my($t, $baseurl)=@_;
  my($a, $b)               = $t=~/\s*([!#]*".*?")\s+(.*)/;
  (defined $a) or ($a, $b) = $t=~/(\S*)(?:\s+(.*))?/;
  $a=~s/"//g;
  $b = escape($b);
  my $href;
  if($a =~ m!https?://!){
    $href = $a;
  }elsif($a =~ /^[\d_]+$/){
    $href = "$baseurl?aid=$a";
#  }elsif(my($str) = $a =~ /^"(.*)"/){
#    $str =~ s/([^ 0-9a-zA-Z])/"%".uc(unpack("H2",$1))/eg;
#    $str =~ s/ /+/g;
#    $href = "$baseurl?txt=$str";
  }elsif(my($img) = $a=~/^!(.*)/){
    return(qq!<img src="$img" alt="$b">!);
  }else{
    $href = $a;
  }
  ($b eq '') and $b=$a;
  return(qq!<a href="$href">$b</a>!);
}

sub make_table{
  my($in)=@_;
  my $ln=0;
  my @tableitem;
  my @out;
  foreach my $line (split(/\n/, $in)){
    $line=~s/[\n\r]*//g;
    ($line eq '') and next;
    $ln++;
    my @cols = split(/( *\|\S*)/, $line); # $cols[0] is always undef. so delete.
    # standardize
    $cols[-1]=~/^\s+$/  and delete $cols[-1];
    $cols[-1]!~/^\s*\|/ and push(@cols, '|');
    for (my $cn=1; $cn<$#cols; $cn++){
      $cols[$cn]=~s/^\s*//;
      $cols[$cn]=~s/\s*$//;
      $tableitem[$ln][$cn] = $cols[$cn];
    }
  }
  
  #my @rowspan = map {0} 0..$#{$tableitem[1]};
  my @colclass; 
  for($ln=$#tableitem; $ln>=1; $ln--){
    if($tableitem[$ln][1]=~/\^\^/ and $ln>1){ # row merge
      for(my $i=2; $i<=$#{$tableitem[$ln]}; $i+=2){
        $tableitem[$ln-1][$i] .= "\n".$tableitem[$ln][$i]; # copy to upper tableitem
      }
      next;
    }
    my $colspan=0;
    my $val='';
    #my %copt;
    my $ctag;
    my @rowclass;
    for(my $cn=$#{$tableitem[$ln]}; $cn>=0; $cn--){
      my $col = $tableitem[$ln][$cn];
      if($cn%2==1){ # border
        #undef %copt;
        $ctag = ($col=~/\bh\b/)?'th':'td';

        if($col=~/-/){ # colspan
          $colspan++;
          next;
        }elsif($colspan>0){
          #$copt{colspan} = $colspan+1;
          $colspan=0;
        }

        if($col=~/\^/){ # rowspan
          $tableitem[$ln-1][$cn+1] .= "\n" . $tableitem[$ln][$cn+1]; # merge data block to upper row 
          # $rowspan[$cn]++;
          (defined $out[$ln][$cn]{copt}{rowspan}) or $out[$ln][$cn]{copt}{rowspan} = 1;
          $out[$ln-1][$cn]{copt}{rowspan} = $out[$ln][$cn]{copt}{rowspan}+1;
          next;
#        }elsif($rowspan[$cn]>0){
#          $copt{rowspan} = $rowspan[$cn]+1; # <td rowspan="...
#          $rowspan[$cn]=0;
        }

        if(my(@class)=$col=~/(?<!\.)(\.{1,3}[a-zA-Z0-9_]+)/g){
          foreach my $c (@class){
            my($a,$b) = $c=~/(\.*)(.*)/;
            if($a eq '.'){ # cell class
              push(@{$out[$ln][$cn]{copt}{class}}, $b);
            }elsif($a eq '..'){ # row class
              push(@rowclass, $b);
            }elsif($a eq '...'){# col class
              push(@{$colclass[$cn]}, $b);
              print STDERR "$a $b colclass ", join(",", @colclass), ".\n";              
            }
          }
        }
        my $c1 = $cn/2+1;
        $out[$ln][$c1]{ctag} = $ctag;
        $out[$ln][$c1]{val}  = $val;
      }else{ # value
        $val = $col;
      }
    } # $cn

    for(my $i=1; $i<=$#{$out[$ln]}; $i++){ # set winified text to cells
      (defined $out[$ln][$i]) or next;
      my $cell = $out[$ln][$i];
      $cell->{wini} = wini($cell->{val}, {para=>'nb', nocr=>1});
      $cell->{wini} =~ s/\t *//g;
      $cell->{wini} =~ s/[ \n]+/ /g;
      $out[$ln][$i] = $cell; # $out[$ln][0]: data for row (tr)
    }
    ($rowclass[0]) and $out[$ln][0] = ' class="' . join(' ', @rowclass) . '"';
  } # for $ln
  for(my $cn=1; $cn<=$#{$out[1]}; $cn++){ # set colclass to cells
    map {(defined $colclass[$cn]) and push(@{$out[$_][$cn]{copt}{class}}, @{$colclass[$cn]}) } 1..$#out;
  }

  my $outtxt = qq!<table class="markdowntable">\n!;
  for(my $rn=1; $rn<=$#out; $rn++){
    my $i=0;
    $outtxt .= "<tr$out[$rn][0]>";
    $outtxt .= join("", 
      map { # for each cell
        $i++;
        if((defined $_->{copt}{rowspan} and $_->{copt}{rowspan}<=1) or (defined $_->{copt}{colspan} and $_->{copt}{colspan}<=1)){
          '';
        }else{
          my $copt = '';
          foreach my $c (qw/class colspan rowspan/){
            if(defined $_->{copt}{$c}){
              $copt .= sprintf(qq{ $c="%s"},
                (ref $_->{copt}{$c} eq 'ARRAY') ? join(' ', @{$_->{copt}{$c}}) : $_->{copt}{$c});
            }
          }
          sprintf("<%s$copt>$i %s</%s>", $_->{ctag}, $_->{wini}, $_->{ctag} )
        }
      } @{$out[$rn]}[1 .. $#{$out[1]}]
    );
    $outtxt .= "</tr>\n";
  }
  $outtxt .= "</table>\n";
  $outtxt=~s/\t+/ /g; # tab is separator of cells vertically unified
  return($outtxt);
}

1;
